using JuMP, Mosek, MosekTools
using Graphs
using GraphPlot, Compose
using LinearAlgebra

model = Model(Mosek.Optimizer)
NUM_CTRL_POINTS = 4
NUM_DIMS = 2

n = NUM_CTRL_POINTS * NUM_DIMS + 1 # we also include 1

@variable(model, X[1:n, 1:n], PSD)

@constraint(model, X[1,1] == 1)

# Cost
function create_Q_i(i)
    Q_i = zeros(n, n)
    temp = 2 * [I(NUM_DIMS) -I(NUM_DIMS);
               -I(NUM_DIMS) I(NUM_DIMS)];
    start_index = i * NUM_DIMS
    Q_i[start_index:start_index+NUM_DIMS*2-1, start_index:start_index+NUM_DIMS*2-1] .= temp
    return Q_i
end

Q = sum([create_Q_i(i) for i ∈ 1:NUM_CTRL_POINTS-1])

@objective(model, Min, tr(Q * X'))

# Unit vectors
function e_i(i)
    v = zeros(n)
    v[i] = 1
    return v
end

## SO(2) constraints 
for i ∈ 1:2:n-1
    Q_eq = -e_i(i+1) * e_i(i+1)' - e_i(i+2) * e_i(i+2)'
    Q_eq[1,1] = 1
    @show(Q_eq)
    @constraint(model, tr(Q_eq * X') == 0)
end

# Initial and final condition
x = X[:,1]

θ_0 = 0;
θ_T = π / 2;

r_0 = [cos(θ_0); sin(θ_0)];
r_T = [cos(θ_T); sin(θ_T)];

A_0 = zeros(NUM_DIMS,n-1)
A_0[1,1] = 1
A_0[2,2] = 1

A_T = zeros(NUM_DIMS,n-1)
A_T[1,end-1] = 1
A_T[2,end] = 1

A_eq = [-r_0 A_0;
        -r_T A_T]

@constraint(model, A_eq * X .== 0)
@constraint(model, A_eq * X * e_i(1) .== 0)

# Solve the problem
optimize!(model)

x_val = value.(x)[2:end]

points = reshape(x_val, (NUM_DIMS, NUM_CTRL_POINTS))'

using Plots
plot(points[:,1], points[:,2], label="", ylims=(-1.5, 1.5), xlims=(-1.5, 1.5))
scatter!(points[:,1], points[:,2], label="Ctrl points")
#ϵ = 0.1
#annotate!(points[:,1] + ϵ , points[:,2] + ϵ, string.(1:NUM_CTRL_POINTS))